<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web å›¾ç‰‡å»æ°´å°å·¥å…· (æ”¯æŒæ’¤é”€/é‡åš)</title>
    <style>
        :root {
            --primary: #4f46e5;
            --bg: #1f2937;
            --panel: #111827;
            --text: #f3f4f6;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        header {
            width: 100%;
            padding: 15px;
            background-color: var(--panel);
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            height: 60px;
        }

        h1 { font-size: 1.1rem; font-weight: 500; }
        .shortcuts { font-size: 0.8rem; color: #9ca3af; }

        .toolbar {
            display: flex;
            gap: 12px;
            padding: 10px;
            background-color: var(--panel);
            border-radius: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        button, label.btn {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            user-select: none;
        }

        button:hover:not(:disabled), label.btn:hover { background-color: #4b5563; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        button.active {
            background-color: var(--primary);
            border-color: var(--primary);
        }

        input[type="file"] { display: none; }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            width: 100%;
            position: relative;
            background-image: 
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #2a2a2a 75%), 
                linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            cursor: crosshair;
            margin-top: 10px;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 95%;
            max-height: 80vh;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.2);
            padding: 4px 10px;
            border-radius: 4px;
        }

        input[type="range"] { accent-color: var(--primary); cursor: pointer; }

        #cursor-circle {
            position: absolute;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            display: none;
            z-index: 100;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .hint {
            font-size: 0.85rem;
            color: #9ca3af;
            background: var(--panel);
            width: 100%;
            text-align: center;
            padding: 5px 0;
            border-top: 1px solid #374151;
        }
        
        .divider { width: 1px; height: 24px; background: #4b5563; margin: 0 5px; }
    </style>
</head>
<body>

<header>
    <h1>Web å»æ°´å°å·¥å…· v2.0</h1>
    <div class="shortcuts">å¿«æ·é”®: æ’¤é”€ (Ctrl+Z) / é‡åš (Ctrl+Y) / å–è‰² (Alt+Click)</div>
</header>

<div class="toolbar">
    <label class="btn">
        ğŸ“‚ æ‰“å¼€å›¾ç‰‡
        <input type="file" id="upload" accept="image/*">
    </label>

    <div class="controls">
        <span>ç¬”åˆ·:</span>
        <input type="range" id="brushSize" min="5" max="150" value="30">
        <span id="brushSizeVal">30</span>
    </div>

    <div class="divider"></div>

    <button id="btnClone" class="active" title="å…‹éš†å°ç« : æŒ‰ä½Altç‚¹å‡»å–è‰²ï¼Œç„¶åæ¶‚æŠ¹">ğŸ¯ å…‹éš†å°ç« </button>
    <button id="btnBlur" title="æ¨¡ç³Šå·¥å…·: é€‚åˆçº¯è‰²èƒŒæ™¯">ğŸ’§ æ¨¡ç³Š/å¹³æ»‘</button>

    <div class="divider"></div>

    <button id="btnUndo" disabled title="æ’¤é”€ (Ctrl+Z)">â†©ï¸ æ’¤é”€</button>
    <button id="btnRedo" disabled title="é‡åš (Ctrl+Y)">â†ªï¸ é‡åš</button>
    
    <div class="divider"></div>

    <button id="btnSave" style="background-color: #059669; border-color: #059669;">ğŸ’¾ ä¿å­˜</button>
</div>

<div class="canvas-container" id="container">
    <div id="cursor-circle"></div>
    <canvas id="canvas"></canvas>
</div>

<div class="hint" id="statusText">å½“å‰æ¨¡å¼ï¼šå…‹éš†å°ç«  (1. æŒ‰ä½ Alt+å·¦é”®ç‚¹å‡»å¹²å‡€åŒºåŸŸå–æ · 2. æ¶‚æŠ¹æ°´å°)</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const container = document.getElementById('container');
    const cursor = document.getElementById('cursor-circle');
    const uploadInput = document.getElementById('upload');
    const statusText = document.getElementById('statusText');
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    
    // State
    let isDrawing = false;
    let mode = 'clone'; 
    let brushSize = 30;
    let cloneSource = null; 
    let currentOffset = null;

    // --- History System (Undo/Redo) ---
    // Using ImageData is faster than DataURL for frequent drawing
    let historyStack = [];
    let historyStep = -1;
    const MAX_HISTORY = 30;

    function initHistory(width, height) {
        historyStack = [];
        historyStep = -1;
        saveState(); // Save initial blank or loaded state
    }

    function saveState() {
        historyStep++;
        // If we are in the middle of history and draw new stuff, remove future states
        if (historyStep < historyStack.length) {
            historyStack.length = historyStep;
        }
        // Save full canvas state
        historyStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        
        // Limit memory usage
        if (historyStack.length > MAX_HISTORY) {
            historyStack.shift();
            historyStep--;
        }
        updateHistoryButtons();
    }

    function undo() {
        if (historyStep > 0) {
            historyStep--;
            ctx.putImageData(historyStack[historyStep], 0, 0);
            updateHistoryButtons();
        }
    }

    function redo() {
        if (historyStep < historyStack.length - 1) {
            historyStep++;
            ctx.putImageData(historyStack[historyStep], 0, 0);
            updateHistoryButtons();
        }
    }

    function updateHistoryButtons() {
        btnUndo.disabled = (historyStep <= 0);
        btnRedo.disabled = (historyStep >= historyStack.length - 1);
    }

    // --- Main Logic ---

    // 1. Upload
    uploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                initHistory(); // Reset history for new image
                cloneSource = null; // Reset clone source
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // 2. Brush Size
    document.getElementById('brushSize').addEventListener('input', (e) => {
        brushSize = parseInt(e.target.value);
        document.getElementById('brushSizeVal').textContent = brushSize;
        updateCursorSize();
    });

    // 3. Modes
    document.getElementById('btnClone').addEventListener('click', (e) => {
        setMode('clone', e.target);
        statusText.textContent = "å½“å‰æ¨¡å¼ï¼šå…‹éš†å°ç«  (æŒ‰ä½ Alt+ç‚¹å‡» å–æ ·ï¼Œç„¶åæ¶‚æŠ¹)";
    });
    
    document.getElementById('btnBlur').addEventListener('click', (e) => {
        setMode('blur', e.target);
        statusText.textContent = "å½“å‰æ¨¡å¼ï¼šæ¨¡ç³Š/å¹³æ»‘ (ç›´æ¥æ¶‚æŠ¹æ°´å°åŒºåŸŸ)";
    });

    function setMode(newMode, btn) {
        mode = newMode;
        document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
        if(btn) btn.classList.add('active');
    }

    // 4. Drawing Events
    container.addEventListener('mousedown', startDraw);
    window.addEventListener('mouseup', stopDraw); // Window to catch release outside canvas
    container.addEventListener('mousemove', (e) => {
        moveCursor(e);
        draw(e);
    });

    // Keyboard Shortcuts
    window.addEventListener('keydown', (e) => {
        // Alt for Clone Picker
        if (e.key === 'Alt' && mode === 'clone') {
            container.style.cursor = 'crosshair';
            cursor.style.borderColor = '#ef4444';
        }
        
        // Undo/Redo (Ctrl+Z, Ctrl+Y, Ctrl+Shift+Z)
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            if (e.shiftKey) {
                redo();
            } else {
                undo();
            }
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
            e.preventDefault();
            redo();
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key === 'Alt') {
            container.style.cursor = 'default';
            cursor.style.borderColor = 'white';
        }
    });

    // --- Drawing Functions ---

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function startDraw(e) {
        if (!canvas.width) return;
        
        // Handle Left Click Only
        if (e.button !== 0) return;

        const pos = getMousePos(e);

        // ALT + Click = Set Clone Source
        if (mode === 'clone' && e.altKey) {
            cloneSource = { x: pos.x, y: pos.y };
            statusText.textContent = `âœ… å–æ ·ç‚¹å·²è®¾ç½® (${Math.round(pos.x)}, ${Math.round(pos.y)})ã€‚æ¾å¼€ Alt å¼€å§‹æ¶‚æŠ¹ã€‚`;
            
            // Visual feedback
            const flash = document.createElement('div');
            Object.assign(flash.style, {
                position: 'fixed', left: e.clientX+'px', top: e.clientY+'px',
                width: '10px', height: '10px', background: '#ef4444',
                borderRadius: '50%', pointerEvents: 'none', zIndex: 1000
            });
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 400);
            return;
        }

        if (mode === 'clone' && !cloneSource) {
            alert("âš ï¸ è¯·å…ˆå–æ ·ï¼\n\næ“ä½œæ–¹æ³•ï¼š\næŒ‰ä½é”®ç›˜ Alt é”® -> é¼ æ ‡ç‚¹å‡»å¹²å‡€åŒºåŸŸ -> æ¾å¼€ Alt é”® -> å¼€å§‹æ¶‚æŠ¹ã€‚");
            return;
        }

        isDrawing = true;
        
        // Setup Context
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = brushSize;

        // Clone Offset Calculation (Locks the distance between Source and Brush)
        if (mode === 'clone') {
            currentOffset = {
                x: cloneSource.x - pos.x,
                y: cloneSource.y - pos.y
            };
        }

        draw(e);
    }

    function draw(e) {
        if (!isDrawing) return;
        const pos = getMousePos(e);

        if (mode === 'blur') {
            applyBlur(pos.x, pos.y, brushSize);
        } else if (mode === 'clone' && cloneSource && currentOffset) {
            
            // We draw "patches" along the path. 
            // For smoother stroke, we could interpolate, but for clone stamp, patches work okay.
            
            const srcX = pos.x + currentOffset.x;
            const srcY = pos.y + currentOffset.y;

            ctx.save();
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, brushSize/2, 0, Math.PI*2);
            ctx.clip();
            // Draw image shifted by offset
            // We use simple drawImage which is fast
            ctx.drawImage(canvas, 
                srcX - brushSize/2, srcY - brushSize/2, brushSize, brushSize, // Source Rect
                pos.x - brushSize/2, pos.y - brushSize/2, brushSize, brushSize // Dest Rect
            );
            ctx.restore();
        }
    }

    function stopDraw() {
        if (isDrawing) {
            isDrawing = false;
            currentOffset = null;
            saveState(); // Save state AFTER the stroke is finished
        }
    }

    function applyBlur(x, y, size) {
        const r = size / 2;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.clip();
        ctx.filter = 'blur(4px)'; 
        ctx.drawImage(canvas, 0, 0); 
        ctx.restore();
        ctx.filter = 'none';
    }

    // --- UI Helpers ---
    function moveCursor(e) {
        cursor.style.display = 'block';
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
    }
    
    function updateCursorSize() {
        cursor.style.width = brushSize + 'px';
        cursor.style.height = brushSize + 'px';
    }
    
    container.addEventListener('mouseenter', () => cursor.style.display = 'block');
    container.addEventListener('mouseleave', () => cursor.style.display = 'none');
    updateCursorSize();

    // Button Listeners
    btnUndo.addEventListener('click', undo);
    btnRedo.addEventListener('click', redo);

    document.getElementById('btnSave').addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `removed_${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
    });

</script>
</body>
</html>
